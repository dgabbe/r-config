# The Rprofile.site file
#
# The .Rprofile file is the file users should create/edit for their own
# preferences.
#

# ===========================================================
#
#     REMINDER: This code is sourced into the base environment.
#     Be sure not to overwrite any R funtions, etc.
#
# ===========================================================

if (interactive())
{
  cat(format(Sys.Date(), format = "%d-%b-%Y"),
    " Rprofile.site: ", Sys.getenv("R_PROFILE"), "starting...\n\n"
  )
}

#
# General options
#
# Notes:
#   After using the 'defaultPackage' option for a year, I recommend not using
#   this option to load the libraries you commonly use.  A vanilla R startup includes
#   these packages "datasets", "utils", "grDevices", "graphics", "stats", and "methods".
#   These need to be included if you add some of your own.  The idiom defaultPackages =
#   c(getOption("defaultPackages"), "your package") assumes the code is only
#   executed once which is not guaranteed.  RStudio executing the devtools functions cause
#   the R session initialization code to run.  "your package" is appended again to the
#   default package list and callbacks are added again to the task callback manager.
#
options(
  tab.width = 2,
  digits = 4,
  papersize = "letter",
  stringsAsFactors = FALSE, # Correct for now, wonder if/when it will bite me.
  repos = c(CRAN = "https://cran.rstudio.com/"), # Specify HTTPS connection!
  formatR.indent = 2,
  browserNLdisabled = TRUE # ignore newlines when browse()ing - Hadley tip
##  deparse.max.lines = 2 # give minimal output from traceback() - Hadley tip
)

#
# R and RStudio can have different settings for CRAN https connections.
# Explicitly set to HTTPS.
#
# References: https://support.rstudio.com/hc/en-us/articles/206827897-Secure-Package-Downloads-for-R
#
local({
    if (.Platform$OS.type == "unix") { options(download.file.method = "libcurl")
    } else { options(download.file.method = "wininet") }
})

# R's completion generator
utils::rc.settings(
  ipck = TRUE,   # Enable tab completion for library() & require()
  help = TRUE,   # Enable tab completion for ?help
  data = TRUE    # Enable tab completion for data sets inside utils::data()
  )

#
# Use require() instead of library() because initialization code should never
# fail due to personal preference.
#
# Constantly loading devtools. Decided to make them available for interactive work.
#
# dgutil contains ggplot themes so always attach if package was installed.
#
# References: http://yihui.name/en/2014/07/library-vs-require/
#
.First <- function() {
  if (interactive()) { require("devtools", quietly = TRUE)}
  require("dgutil", quietly = TRUE)
}

if (interactive()) {
  cat("    Option StringsAsFactors:  ", getOption("stringsAsFactors"), "\n")
  cat("    Option download.file.method:  ", getOption("download.file.method"), "\n")
  cat("    Option repos:  ", getOption("repos"), "\n")
  cat(
    strwrap(
      toString(getOption("defaultPackages")),
      width = 80,
      initial = "    Option defaultPackages: ",
      prefix = "",
      indent = 0,
      exdent = nchar("        ")
    ),
    sep = "\n"
  )
  cat("\n", format(Sys.Date(), format = "%d-%b-%Y"),
    " Rprofile.site: ", Sys.getenv("R_PROFILE"), "finished...\n\n"
  )
}


# Emulate bash command line prompt behavior in R console.  RStudio does display
# the current working directory in the Console window title bar, but it is not
# where I reflexively look.
#
# Execute in local context so base environment remains unmodified.
#
# The code for the task callback is a copy of the function.  The global
# environment can be cleared and the prompt behavior continues to work.
#
# If you don't like how this work, it can be removed by:
#   1. removeTaskCallback("wd_prompt")
#   2. options(prompt=paste("your string here"))
#
# References:
#    - https://stackoverflow.com/questions/4222476/r-display-a-time-clock-in-the-r-command-line
#    - https://stackoverflow.com/questions/25136059/how-to-show-working-directory-in-r-prompt
#
local({
  use_wd_prompt <- TRUE # Set to FALSE if you don't want the prompt

  if (use_wd_prompt & interactive() & !"wd_prompt" %in% getTaskCallbackNames()) {
    wd_prompt <- function(...) {
      # There are no arguments because the callback task manager doesn't allow for
      # optional function arguments. Since you need to add a callback if you want to
      # change the behavior, it's no different than changing the variables below.

      # Set the prompt to display the current working directory according to personal preferences.
      fullPath <- TRUE
      promptLen <- c(15)

      curDir <- getwd()
      if (fullPath) {
        # Mirror the behavior by my bash prompt.
        options(prompt = paste(curDir, ">\n"))
      } else {
        if (nchar(curDir) <= promptLen) {
          options(prompt = paste(curDir,"> "))
        } else {
          options(prompt = paste("...", substring(curDir, nchar(curDir) - 15), "> "))
        }
      }
      TRUE
    }

    sink("/dev/null") # suppress output
      addTaskCallback(wd_prompt, data=NULL, name="wd_prompt")
      wd_prompt() # Init prompt for first time
    sink()
  }
})

